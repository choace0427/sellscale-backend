import csv
from datetime import datetime, timedelta
import re
from src.bump_framework.models import BumpFramework
from src.client.models import ClientSDR
from src.client.sdr.services_client_sdr import get_sdr_blacklist_words
from src.message_generation.models import GeneratedMessageAutoBump

# This MUST be changed when the relative path of the csv's changes.
PROFANITY_CSV_PATH = r"src/../datasets/profanity.csv"


def run_autobump_firewall(generated_message_autobump_id: int) -> tuple[bool, list[str]]:
    """Run the firewall service.

    Args:
        generated_message_auto_bump_id (int): The ID of the GeneratedMessageAutoBump

    Returns:
        tuple[bool, list[str]]: A tuple containing a boolean indicating whether the
            service ran successfully and a list of violations if the service failed.
    """
    # Get the autobump
    autobump: GeneratedMessageAutoBump = GeneratedMessageAutoBump.query.get(
        generated_message_autobump_id
    )
    if not autobump:
        return False, "Message not found"

    # Get the message
    message = autobump.message

    # Run the firewall rules
    violations = []
    rule_minimum_character_count(message, violations)
    rule_cant_be_blank(message, violations)
    rule_default_framework(autobump.id, violations)
    rule_no_stale_message(autobump.id, violations)
    rule_no_sdr_name_in_message(autobump.id, violations)
    rule_no_profanity(message, violations)

    # If there are any violations, return False
    if len(violations) > 0:
        return False, violations

    return True, []


def rule_no_blacklist_words(message: str, violations: list, client_sdr_id: int) -> tuple[bool, str]:
    """Rule: Message cannot contain any words in the SDR's blacklist."""
    # Get the blacklist words
    blacklist_words = get_sdr_blacklist_words(client_sdr_id)
    if not blacklist_words:
        return True, "Success"

    # Check the message for blacklist words
    detected_blacklist_words = []
    for word in message.split():
        stripped_word = re.sub(
            "[^0-9a-zA-Z]+",
            "",
            word,
        ).strip()
        if word in blacklist_words:
            detected_blacklist_words.append("'" + word + "'")
        elif stripped_word in blacklist_words:
            detected_blacklist_words.append("'" + stripped_word + "'")

    if detected_blacklist_words:
        violations.append(
            "Message contains blacklisted words: " + ", ".join(detected_blacklist_words)
        )
        return False, "Message contains blacklisted words: " + ", ".join(detected_blacklist_words)

    return True, "Success"


def rule_minimum_character_count(message: str, violations: list) -> tuple[bool, str]:
    """Rule: Message must be more than 15 characters long."""
    if len(message) < 15:
        violations.append("Message shorter than 15 characters.")
        return False, "Message shorter than 15 characters."

    return True, "Success"


def rule_cant_be_blank(message: str, violations: list) -> tuple[bool, str]:
    """Rule: Message can't be blank."""
    if message.strip() == "":
        violations.append("Message is blank.")
        return False, "Message is blank."

    return True, "Success"


def rule_default_framework(autobump_id: int, violations: list) -> tuple[bool, str]:
    """Rule: Message must be generated by a default framework."""
    # Get the autobump
    autobump: GeneratedMessageAutoBump = GeneratedMessageAutoBump.query.get(autobump_id)
    bump_framework: BumpFramework = BumpFramework.query.get(autobump.bump_framework_id)
    if not bump_framework:
        violations.append("Bump framework no longer exists")
        return False, "Bump framework no longer exists"
    if not bump_framework.default:
        violations.append("Bump framework (#{}) is not default".format(bump_framework.id))
        return False, "Bump framework is not default"

    return True, "Success"


def rule_no_stale_message(autobump_id: int, violations: list) -> tuple[bool, str]:
    """Rule: Messages cannot be stale (generated more than 3 days ago)"""
    # Get the autobump
    autobump: GeneratedMessageAutoBump = GeneratedMessageAutoBump.query.get(autobump_id)
    if autobump.created_at < datetime.now() - timedelta(days=3):
        violations.append("Message is stale (generated more than 3 days ago)")
        return False, "Message is stale (generated more than 3 days ago)"

    return True, "Success"


def rule_no_sdr_name_in_message(autobump_id: int, violations: list) -> tuple[bool, str]:
    """Rule: Message cannot contain the SDR's name."""
    # Get the autobump
    autobump: GeneratedMessageAutoBump = GeneratedMessageAutoBump.query.get(autobump_id)
    # Get the framework
    bump_framework: BumpFramework = BumpFramework.query.get(autobump.bump_framework_id)
    # Get the SDR
    sdr: ClientSDR = ClientSDR.query.get(bump_framework.client_sdr_id)
    if not sdr:
        violations.append("SDR no longer exists")
        return False, "SDR no longer exists"
    if sdr.name + ":" in autobump.message:
        violations.append("Message contains SDR name")
        return False, "Message contains SDR name"

    return True, "Success"


def rule_no_profanity(message: str, violations: list) -> tuple[bool, str]:
    """Rule: Message cannot contain profanity."""
    # Get the profane words
    with open(PROFANITY_CSV_PATH, newline="") as f:
        reader = csv.reader(f)
        profanity = set([row[0] for row in reader])

    detected_profanities = []
    for word in message.split():
        stripped_word = re.sub(
            "[^0-9a-zA-Z]+",
            "",
            word,
        ).strip()
        if word in profanity:
            detected_profanities.append("'" + word + "'")
        elif stripped_word in profanity:
            detected_profanities.append("'" + stripped_word + "'")

    if detected_profanities:
        violations.append(
            "Message contains profanity: " + ", ".join(detected_profanities)
        )
        return False, "Message contains profanity: " + ", ".join(detected_profanities)

    return True, "Success"
